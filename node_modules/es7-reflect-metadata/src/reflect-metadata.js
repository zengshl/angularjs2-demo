"use strict";
var get_proto_of_type_1 = require("./helper/get-proto-of-type");
var to_property_key_1 = require("./helper/to-property-key");
var is_constructor_1 = require("./helper/is-constructor");
var is_undefined_1 = require("./helper/is-undefined");
var is_array_1 = require("./helper/is-array");
var is_object_1 = require("./helper/is-object");
var metadata_1 = require("./helper/metadata");
var ordinary_own_metadata_keys_1 = require("./helper/ordinary-own-metadata-keys");
var get_or_create_metadata_map_1 = require("./helper/get-or-create-metadata-map");
var ordinary_metadata_keys_1 = require("./helper/ordinary-metadata-keys");
/**
 * Applies a set of decorators to a property of a target object.
 * @param decorators An array of decorators.
 * @param target The target object.
 * @param targetKey (Optional) The property key to decorate.
 * @param targetDescriptor (Optional) The property descriptor for the target key
 * @remarks Decorators are applied in reverse order.
 * @example
 *
 *     class C {
 *         // property declarations are not part of ES6, though they are valid in TypeScript:
 *         // static staticProperty;
 *         // property;
 *
 *         constructor(p) { }
 *         static staticMethod(p) { }
 *         method(p) { }
 *     }
 *
 *     // constructor
 *     C = Reflect.decorate(decoratorsArray, C);
 *
 *     // property (on constructor)
 *     Reflect.decorate(decoratorsArray, C, "staticProperty");
 *
 *     // property (on prototype)
 *     Reflect.decorate(decoratorsArray, C.prototype, "property");
 *
 *     // method (on constructor)
 *     Object.defineProperty(C, "staticMethod",
 *         Reflect.decorate(decoratorsArray, C, "staticMethod",
 *             Object.getOwnPropertyDescriptor(C, "staticMethod")));
 *
 *     // method (on prototype)
 *     Object.defineProperty(C.prototype, "method",
 *         Reflect.decorate(decoratorsArray, C.prototype, "method",
 *             Object.getOwnPropertyDescriptor(C.prototype, "method")));
 *
 */
function decorate(decorators, target, targetKey, targetDescriptor) {
    if (!is_undefined_1.isUndefined(targetDescriptor)) {
        if (!is_array_1.isArray(decorators)) {
            throw new TypeError('decorators ' + decorators + ' is not an array of decorators');
        }
        else if (!is_object_1.isObject(target)) {
            throw new TypeError('target ' + target + ' is not an object');
        }
        else if (is_undefined_1.isUndefined(targetKey)) {
            throw new TypeError('target key ' + targetKey + 'is undefined');
        }
        else if (!is_object_1.isObject(targetDescriptor)) {
            throw new TypeError('targetDescriptor ' + targetDescriptor + ' is not an object');
        }
        targetKey = to_property_key_1.toPropertyKey(targetKey);
        return DecoratePropertyWithDescriptor(decorators, target, targetKey, targetDescriptor);
    }
    else if (!is_undefined_1.isUndefined(targetKey)) {
        if (!is_array_1.isArray(decorators)) {
            throw new TypeError('decorators ' + decorators + ' is not an array of decorators');
        }
        else if (!is_object_1.isObject(target)) {
            throw new TypeError('target ' + target + ' is not an object');
        }
        targetKey = to_property_key_1.toPropertyKey(targetKey);
        return DecoratePropertyWithoutDescriptor(decorators, target, targetKey);
    }
    else {
        if (!is_array_1.isArray(decorators)) {
            throw new TypeError('decorators ' + decorators + ' is not an array of decorators');
        }
        else if (!is_constructor_1.isConstructor(target)) {
            throw new TypeError('target ' + target + ' is not a constructor');
        }
        return DecorateConstructor(decorators, target);
    }
}
exports.decorate = decorate;
/**
 * A default metadata decorator factory that can be used on a class, class member, or parameter.
 * @param metadataKey The key for the metadata entry.
 * @param metadataValue The value for the metadata entry.
 * @returns A decorator function.
 * @remarks
 * If `metadataKey` is already defined for the target and target key, the
 * metadataValue for that key will be overwritten.
 * @example
 *
 *     // constructor
 *     @Reflect.metadata(key, value)
 *     class C {
 *     }
 *
 *     // property (on constructor, TypeScript only)
 *     class C {
 *         @Reflect.metadata(key, value)
 *         static staticProperty;
 *     }
 *
 *     // property (on prototype, TypeScript only)
 *     class C {
 *         @Reflect.metadata(key, value)
 *         property;
 *     }
 *
 *     // method (on constructor)
 *     class C {
 *         @Reflect.metadata(key, value)
 *         static staticMethod() { }
 *     }
 *
 *     // method (on prototype)
 *     class C {
 *         @Reflect.metadata(key, value)
 *         method() { }
 *     }
 *
 */
function metadata(metadataKey, metadataValue) {
    function decorator(target, targetKey) {
        if (!is_undefined_1.isUndefined(targetKey)) {
            if (!is_object_1.isObject(target)) {
                throw new TypeError('target ' + target + ' is not an object');
            }
            targetKey = to_property_key_1.toPropertyKey(targetKey);
            OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, targetKey);
        }
        else {
            if (!is_constructor_1.isConstructor(target)) {
                throw new TypeError('target ' + target + ' is not a constructor');
            }
            OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, /*targetKey*/ undefined);
        }
    }
    return decorator;
}
exports.metadata = metadata;
/**
 * Define a unique metadata entry on the target.
 * @param metadataKey A key used to store and retrieve metadata.
 * @param metadataValue A value that contains attached metadata.
 * @param target The target object on which to define metadata.
 * @param targetKey (Optional) The property key for the target.
 * @example
 *
 *     class C {
 *         // property declarations are not part of ES6, though they are valid in TypeScript:
 *         // static staticProperty;
 *         // property;
 *
 *         constructor(p) { }
 *         static staticMethod(p) { }
 *         method(p) { }
 *     }
 *
 *     // constructor
 *     Reflect.defineMetadata("custom:annotation", options, C);
 *
 *     // property (on constructor)
 *     Reflect.defineMetadata("custom:annotation", options, C, "staticProperty");
 *
 *     // property (on prototype)
 *     Reflect.defineMetadata("custom:annotation", options, C.prototype, "property");
 *
 *     // method (on constructor)
 *     Reflect.defineMetadata("custom:annotation", options, C, "staticMethod");
 *
 *     // method (on prototype)
 *     Reflect.defineMetadata("custom:annotation", options, C.prototype, "method");
 *
 *     // decorator factory as metadata-producing annotation.
 *     function MyAnnotation(options): Decorator {
 *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
 *     }
 *
 */
function defineMetadata(metadataKey, metadataValue, target, targetKey) {
    if (!is_object_1.isObject(target)) {
        throw new TypeError('target ' + target + ' is not an object');
    }
    else if (!is_undefined_1.isUndefined(targetKey)) {
        targetKey = to_property_key_1.toPropertyKey(targetKey);
    }
    return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, targetKey);
}
exports.defineMetadata = defineMetadata;
/**
 * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
 * @param metadataKey A key used to store and retrieve metadata.
 * @param target The target object on which the metadata is defined.
 * @param targetKey (Optional) The property key for the target.
 * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
 * @example
 *
 *     class C {
 *         // property declarations are not part of ES6, though they are valid in TypeScript:
 *         // static staticProperty;
 *         // property;
 *
 *         constructor(p) { }
 *         static staticMethod(p) { }
 *         method(p) { }
 *     }
 *
 *     // constructor
 *     result = Reflect.hasMetadata("custom:annotation", C);
 *
 *     // property (on constructor)
 *     result = Reflect.hasMetadata("custom:annotation", C, "staticProperty");
 *
 *     // property (on prototype)
 *     result = Reflect.hasMetadata("custom:annotation", C.prototype, "property");
 *
 *     // method (on constructor)
 *     result = Reflect.hasMetadata("custom:annotation", C, "staticMethod");
 *
 *     // method (on prototype)
 *     result = Reflect.hasMetadata("custom:annotation", C.prototype, "method");
 *
 */
function hasMetadata(metadataKey, target, targetKey) {
    if (!is_object_1.isObject(target)) {
        throw new TypeError('target ' + target + ' is not an object');
    }
    else if (!is_undefined_1.isUndefined(targetKey)) {
        targetKey = to_property_key_1.toPropertyKey(targetKey);
    }
    return OrdinaryHasMetadata(metadataKey, target, targetKey);
}
exports.hasMetadata = hasMetadata;
/**
 * Gets a value indicating whether the target object has the provided metadata key defined.
 * @param metadataKey A key used to store and retrieve metadata.
 * @param target The target object on which the metadata is defined.
 * @param targetKey (Optional) The property key for the target.
 * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
 * @example
 *
 *     class C {
 *         // property declarations are not part of ES6, though they are valid in TypeScript:
 *         // static staticProperty;
 *         // property;
 *
 *         constructor(p) { }
 *         static staticMethod(p) { }
 *         method(p) { }
 *     }
 *
 *     // constructor
 *     result = Reflect.hasOwnMetadata("custom:annotation", C);
 *
 *     // property (on constructor)
 *     result = Reflect.hasOwnMetadata("custom:annotation", C, "staticProperty");
 *
 *     // property (on prototype)
 *     result = Reflect.hasOwnMetadata("custom:annotation", C.prototype, "property");
 *
 *     // method (on constructor)
 *     result = Reflect.hasOwnMetadata("custom:annotation", C, "staticMethod");
 *
 *     // method (on prototype)
 *     result = Reflect.hasOwnMetadata("custom:annotation", C.prototype, "method");
 *
 */
function hasOwnMetadata(metadataKey, target, targetKey) {
    if (!is_object_1.isObject(target)) {
        throw new TypeError('target ' + target + ' is not an object');
    }
    else if (!is_undefined_1.isUndefined(targetKey)) {
        targetKey = to_property_key_1.toPropertyKey(targetKey);
    }
    return OrdinaryHasOwnMetadata(metadataKey, target, targetKey);
}
exports.hasOwnMetadata = hasOwnMetadata;
/**
 * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
 * @param metadataKey A key used to store and retrieve metadata.
 * @param target The target object on which the metadata is defined.
 * @param targetKey (Optional) The property key for the target.
 * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
 * @example
 *
 *     class C {
 *         // property declarations are not part of ES6, though they are valid in TypeScript:
 *         // static staticProperty;
 *         // property;
 *
 *         constructor(p) { }
 *         static staticMethod(p) { }
 *         method(p) { }
 *     }
 *
 *     // constructor
 *     result = Reflect.getMetadata("custom:annotation", C);
 *
 *     // property (on constructor)
 *     result = Reflect.getMetadata("custom:annotation", C, "staticProperty");
 *
 *     // property (on prototype)
 *     result = Reflect.getMetadata("custom:annotation", C.prototype, "property");
 *
 *     // method (on constructor)
 *     result = Reflect.getMetadata("custom:annotation", C, "staticMethod");
 *
 *     // method (on prototype)
 *     result = Reflect.getMetadata("custom:annotation", C.prototype, "method");
 *
 */
function getMetadata(metadataKey, target, targetKey) {
    if (!is_object_1.isObject(target)) {
        throw new TypeError('target ' + target + ' is not an object');
    }
    else if (!is_undefined_1.isUndefined(targetKey)) {
        targetKey = to_property_key_1.toPropertyKey(targetKey);
    }
    return OrdinaryGetMetadata(metadataKey, target, targetKey);
}
exports.getMetadata = getMetadata;
/**
 * Gets the metadata value for the provided metadata key on the target object.
 * @param metadataKey A key used to store and retrieve metadata.
 * @param target The target object on which the metadata is defined.
 * @param targetKey (Optional) The property key for the target.
 * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
 * @example
 *
 *     class C {
 *         // property declarations are not part of ES6, though they are valid in TypeScript:
 *         // static staticProperty;
 *         // property;
 *
 *         constructor(p) { }
 *         static staticMethod(p) { }
 *         method(p) { }
 *     }
 *
 *     // constructor
 *     result = Reflect.getOwnMetadata("custom:annotation", C);
 *
 *     // property (on constructor)
 *     result = Reflect.getOwnMetadata("custom:annotation", C, "staticProperty");
 *
 *     // property (on prototype)
 *     result = Reflect.getOwnMetadata("custom:annotation", C.prototype, "property");
 *
 *     // method (on constructor)
 *     result = Reflect.getOwnMetadata("custom:annotation", C, "staticMethod");
 *
 *     // method (on prototype)
 *     result = Reflect.getOwnMetadata("custom:annotation", C.prototype, "method");
 *
 */
function getOwnMetadata(metadataKey, target, targetKey) {
    if (!is_object_1.isObject(target)) {
        throw new TypeError('target ' + target + ' is not an object');
    }
    else if (!is_undefined_1.isUndefined(targetKey)) {
        targetKey = to_property_key_1.toPropertyKey(targetKey);
    }
    return OrdinaryGetOwnMetadata(metadataKey, target, targetKey);
}
exports.getOwnMetadata = getOwnMetadata;
/**
 * Gets the metadata keys defined on the target object or its prototype chain.
 * @param target The target object on which the metadata is defined.
 * @param targetKey (Optional) The property key for the target.
 * @returns An array of unique metadata keys.
 * @example
 *
 *     class C {
 *         // property declarations are not part of ES6, though they are valid in TypeScript:
 *         // static staticProperty;
 *         // property;
 *
 *         constructor(p) { }
 *         static staticMethod(p) { }
 *         method(p) { }
 *     }
 *
 *     // constructor
 *     result = Reflect.getMetadataKeys(C);
 *
 *     // property (on constructor)
 *     result = Reflect.getMetadataKeys(C, "staticProperty");
 *
 *     // property (on prototype)
 *     result = Reflect.getMetadataKeys(C.prototype, "property");
 *
 *     // method (on constructor)
 *     result = Reflect.getMetadataKeys(C, "staticMethod");
 *
 *     // method (on prototype)
 *     result = Reflect.getMetadataKeys(C.prototype, "method");
 *
 */
function getMetadataKeys(target, targetKey) {
    if (!is_object_1.isObject(target)) {
        throw new TypeError('target ' + target + ' is not an object');
    }
    else if (!is_undefined_1.isUndefined(targetKey)) {
        targetKey = to_property_key_1.toPropertyKey(targetKey);
    }
    return ordinary_metadata_keys_1.ordinaryMetadataKeys(target, targetKey);
}
exports.getMetadataKeys = getMetadataKeys;
/**
 * Gets the unique metadata keys defined on the target object.
 * @param target The target object on which the metadata is defined.
 * @param targetKey (Optional) The property key for the target.
 * @returns An array of unique metadata keys.
 * @example
 *
 *     class C {
 *         // property declarations are not part of ES6, though they are valid in TypeScript:
 *         // static staticProperty;
 *         // property;
 *
 *         constructor(p) { }
 *         static staticMethod(p) { }
 *         method(p) { }
 *     }
 *
 *     // constructor
 *     result = Reflect.getOwnMetadataKeys(C);
 *
 *     // property (on constructor)
 *     result = Reflect.getOwnMetadataKeys(C, "staticProperty");
 *
 *     // property (on prototype)
 *     result = Reflect.getOwnMetadataKeys(C.prototype, "property");
 *
 *     // method (on constructor)
 *     result = Reflect.getOwnMetadataKeys(C, "staticMethod");
 *
 *     // method (on prototype)
 *     result = Reflect.getOwnMetadataKeys(C.prototype, "method");
 *
 */
function getOwnMetadataKeys(target, targetKey) {
    if (!is_object_1.isObject(target)) {
        throw new TypeError('target ' + target + ' is not an object');
    }
    else if (!is_undefined_1.isUndefined(targetKey)) {
        targetKey = to_property_key_1.toPropertyKey(targetKey);
    }
    return ordinary_own_metadata_keys_1.ordinaryOwnMetadataKeys(target, targetKey);
}
exports.getOwnMetadataKeys = getOwnMetadataKeys;
/**
 * Deletes the metadata entry from the target object with the provided key.
 * @param metadataKey A key used to store and retrieve metadata.
 * @param target The target object on which the metadata is defined.
 * @param targetKey (Optional) The property key for the target.
 * @returns `true` if the metadata entry was found and deleted; otherwise, false.
 * @example
 *
 *     class C {
 *         // property declarations are not part of ES6, though they are valid in TypeScript:
 *         // static staticProperty;
 *         // property;
 *
 *         constructor(p) { }
 *         static staticMethod(p) { }
 *         method(p) { }
 *     }
 *
 *     // constructor
 *     result = Reflect.deleteMetadata("custom:annotation", C);
 *
 *     // property (on constructor)
 *     result = Reflect.deleteMetadata("custom:annotation", C, "staticProperty");
 *
 *     // property (on prototype)
 *     result = Reflect.deleteMetadata("custom:annotation", C.prototype, "property");
 *
 *     // method (on constructor)
 *     result = Reflect.deleteMetadata("custom:annotation", C, "staticMethod");
 *
 *     // method (on prototype)
 *     result = Reflect.deleteMetadata("custom:annotation", C.prototype, "method");
 *
 */
function deleteMetadata(metadataKey, target, targetKey) {
    if (!is_object_1.isObject(target)) {
        throw new TypeError('target ' + target + ' is not an object');
    }
    else if (!is_undefined_1.isUndefined(targetKey)) {
        targetKey = to_property_key_1.toPropertyKey(targetKey);
    }
    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#deletemetadata-metadatakey-p-
    var metadataMap = get_or_create_metadata_map_1.getOrCreateMetadataMap(target, targetKey, /*create*/ false);
    if (is_undefined_1.isUndefined(metadataMap)) {
        return false;
    }
    if (!metadataMap.delete(metadataKey)) {
        return false;
    }
    if (metadataMap.size > 0) {
        return true;
    }
    var targetMetadata = metadata_1.__Metadata__.get(target);
    targetMetadata.delete(targetKey);
    if (targetMetadata.size > 0) {
        return true;
    }
    metadata_1.__Metadata__.delete(target);
    return true;
}
exports.deleteMetadata = deleteMetadata;
function DecorateConstructor(decorators, target) {
    for (var i = decorators.length - 1; i >= 0; --i) {
        var decorator = decorators[i];
        var decorated = decorator(target);
        if (!is_undefined_1.isUndefined(decorated)) {
            if (!is_constructor_1.isConstructor(decorated)) {
                throw new TypeError('target ' + target + ' is not a constructor');
            }
            target = decorated;
        }
    }
    return target;
}
function DecoratePropertyWithDescriptor(decorators, target, propertyKey, descriptor) {
    for (var i = decorators.length - 1; i >= 0; --i) {
        var decorator = decorators[i];
        var decorated = decorator(target, propertyKey, descriptor);
        if (!is_undefined_1.isUndefined(decorated)) {
            if (!is_object_1.isObject(decorated)) {
                throw new TypeError('decorated ' + decorated + ' is not an object');
            }
            descriptor = decorated;
        }
    }
    return descriptor;
}
function DecoratePropertyWithoutDescriptor(decorators, target, propertyKey) {
    for (var i = decorators.length - 1; i >= 0; --i) {
        var decorator = decorators[i];
        decorator(target, propertyKey);
    }
}
// https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinaryhasmetadata--metadatakey-o-p-
function OrdinaryHasMetadata(MetadataKey, O, P) {
    var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
    if (hasOwn) {
        return true;
    }
    var parent = get_proto_of_type_1.getProtoOfType(O);
    if (parent !== null) {
        return OrdinaryHasMetadata(MetadataKey, parent, P);
    }
    return false;
}
// https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinaryhasownmetadata--metadatakey-o-p-
function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
    var metadataMap = get_or_create_metadata_map_1.getOrCreateMetadataMap(O, P, /*create*/ false);
    if (metadataMap === undefined) {
        return false;
    }
    return Boolean(metadataMap.has(MetadataKey));
}
// https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinarygetmetadata--metadatakey-o-p-
function OrdinaryGetMetadata(MetadataKey, O, P) {
    var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
    if (hasOwn) {
        return OrdinaryGetOwnMetadata(MetadataKey, O, P);
    }
    var parent = get_proto_of_type_1.getProtoOfType(O);
    if (parent !== null) {
        return OrdinaryGetMetadata(MetadataKey, parent, P);
    }
    return undefined;
}
// https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinarygetownmetadata--metadatakey-o-p-
function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
    var metadataMap = get_or_create_metadata_map_1.getOrCreateMetadataMap(O, P, /*create*/ false);
    if (metadataMap === undefined) {
        return undefined;
    }
    return metadataMap.get(MetadataKey);
}
// https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinarydefineownmetadata--metadatakey-metadatavalue-o-p-
function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
    var metadataMap = get_or_create_metadata_map_1.getOrCreateMetadataMap(O, P, /*create*/ true);
    metadataMap.set(MetadataKey, MetadataValue);
}
//# sourceMappingURL=reflect-metadata.js.map