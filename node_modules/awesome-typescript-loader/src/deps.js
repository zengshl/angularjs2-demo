var _ = require('lodash');
var path = require('path');
var promisify = require('es6-promisify');
var objectAssign = require('object-assign');
function createResolver(externals, exclude, webpackResolver, ctx) {
    if (ctx === void 0) { ctx = null; }
    var finalResolver = webpackResolver;
    if (webpackResolver.length === 4) {
        // carrying resolver for webpack2
        finalResolver = webpackResolver.bind(ctx, {});
    }
    var resolver = promisify(finalResolver);
    function resolve(base, dep) {
        var inWebpackExternals = externals && externals.hasOwnProperty(dep);
        var inTypeScriptExclude = false;
        if ((inWebpackExternals || inTypeScriptExclude)) {
            return Promise.resolve('%%ignore');
        }
        else {
            return resolver(base, dep).then(function (resultPath) {
                if (Array.isArray(resultPath)) {
                    resultPath = resultPath[0];
                }
                // ignore excluded javascript
                if (!resultPath.match(/.tsx?$/)) {
                    var matchedExcludes = exclude.filter(function (excl) {
                        return resultPath.indexOf(excl) !== -1;
                    });
                    if (matchedExcludes.length > 0) {
                        return '%%ignore';
                    }
                    else {
                        return resultPath;
                    }
                }
                else {
                    return resultPath;
                }
            });
        }
    }
    return resolve;
}
exports.createResolver = createResolver;
function isTypeDeclaration(fileName) {
    return /\.d.ts$/.test(fileName);
}
function isImportOrExportDeclaration(node) {
    return (!!node.exportClause || !!node.importClause)
        && node.moduleSpecifier;
}
function isImportEqualsDeclaration(node) {
    return !!node.moduleReference && node.moduleReference.hasOwnProperty('expression');
}
function isIgnoreDependency(absulutePath) {
    return absulutePath == '%%ignore';
}
var FileAnalyzer = (function () {
    function FileAnalyzer(state) {
        this.dependencies = new DependencyManager();
        this.validFiles = new ValidFilesManager();
        this.state = state;
    }
    FileAnalyzer.prototype.checkDependencies = function (resolver, fileName) {
        if (this.validFiles.isFileValid(fileName)) {
            return false;
        }
        this.validFiles.markFileValid(fileName);
        this.dependencies.clearDependencies(fileName);
        var changed = false;
        try {
            if (!this.state.hasFile(fileName)) {
                changed = yield this.state.readFileAndUpdate(fileName);
            }
            yield this.checkDependenciesInternal(resolver, fileName);
        }
        catch (err) {
            this.validFiles.markFileInvalid(fileName);
            throw err;
        }
        return changed;
    };
    FileAnalyzer.prototype.checkDependenciesInternal = function (resolver, fileName) {
        var imports = yield this.findImportDeclarations(resolver, fileName);
        var tasks = [];
        for (var i = 0; i < imports.length; i++) {
            var importPath = imports[i];
            var isDeclaration = isTypeDeclaration(importPath);
            var isRequiredJs = /\.js$/.exec(importPath) || importPath.indexOf('.') === -1;
            if (isDeclaration) {
                var hasDeclaration = this.dependencies.hasTypeDeclaration(importPath);
                if (!hasDeclaration) {
                    this.dependencies.addTypeDeclaration(importPath);
                    tasks.push(this.checkDependencies(resolver, importPath));
                }
            }
            else if (isRequiredJs && !this.state.options.allowJs) {
                continue;
            }
            else {
                this.dependencies.addDependency(fileName, importPath);
                tasks.push(this.checkDependencies(resolver, importPath));
            }
        }
        yield Promise.all(tasks);
        return null;
    };
    FileAnalyzer.prototype.findImportDeclarations = function (resolver, fileName) {
        var _this = this;
        var sourceFile = this.state.getSourceFile(fileName);
        var isDeclaration = isTypeDeclaration(fileName);
        var imports = [];
        var visit = function (node) {
            if (!isDeclaration && isImportEqualsDeclaration(node)) {
                // we need this check to ensure that we have an external import
                var importPath = node.moduleReference.expression.text;
                imports.push(importPath);
            }
            else if (!isDeclaration && isImportOrExportDeclaration(node)) {
                var importPath = node.moduleSpecifier.text;
                imports.push(importPath);
            }
        };
        imports.push.apply(imports, sourceFile.referencedFiles.map(function (file) { return file.fileName; }));
        this.state.ts.forEachChild(sourceFile, visit);
        var task = imports.map(function (importPath) {
            var absolutePath = yield _this.resolve(resolver, fileName, importPath);
            if (!isIgnoreDependency(absolutePath)) {
                return absolutePath;
            }
        });
        var resolvedImports = yield Promise.all(task);
        // FIXME ts bug
        return resolvedImports.filter(Boolean);
    };
    FileAnalyzer.prototype.resolve = function (resolver, fileName, defPath) {
        var result;
        if (/^[a-z0-9].*\.d\.ts$/.test(defPath)) {
            // Make import relative
            defPath = './' + defPath;
        }
        if (isTypeDeclaration(defPath)) {
            // We MUST NOT resolve symlinks when working with .d.ts files, because/
            // they work whithout module resolution.
            result = Promise.resolve(path.resolve(path.dirname(fileName), defPath));
        }
        else {
            result = resolver(path.dirname(fileName), defPath)
                .catch(function (error) {
                // Node builtin modules
                try {
                    if (require.resolve(defPath) == defPath) {
                        return defPath;
                    }
                    else {
                        throw error;
                    }
                }
                catch (e) {
                    throw error;
                }
            });
        }
        return result
            .catch(function (error) {
            var detailedError = new ResolutionError();
            detailedError.message = error.message + "\n    Required in " + fileName;
            detailedError.cause = error;
            detailedError.fileName = fileName;
            throw detailedError;
        });
    };
    return FileAnalyzer;
})();
exports.FileAnalyzer = FileAnalyzer;
var DependencyManager = (function () {
    function DependencyManager(dependencies, knownTypeDeclarations) {
        if (dependencies === void 0) { dependencies = {}; }
        if (knownTypeDeclarations === void 0) { knownTypeDeclarations = {}; }
        this.dependencies = dependencies;
        this.knownTypeDeclarations = knownTypeDeclarations;
        this.compiledModules = {};
    }
    DependencyManager.prototype.clone = function () {
        return new DependencyManager(_.cloneDeep(this.dependencies), _.cloneDeep(this.knownTypeDeclarations));
    };
    DependencyManager.prototype.addDependency = function (fileName, depFileName) {
        if (!this.dependencies.hasOwnProperty(fileName)) {
            this.clearDependencies(fileName);
        }
        this.dependencies[fileName].push(depFileName);
    };
    DependencyManager.prototype.addCompiledModule = function (fileName, depFileName) {
        if (!this.compiledModules.hasOwnProperty(fileName)) {
            this.clearCompiledModules(fileName);
        }
        var store = this.compiledModules[fileName];
        if (store.indexOf(depFileName) === -1) {
            store.push(depFileName);
        }
    };
    DependencyManager.prototype.clearDependencies = function (fileName) {
        this.dependencies[fileName] = [];
    };
    DependencyManager.prototype.clearCompiledModules = function (fileName) {
        this.compiledModules[fileName] = [];
    };
    DependencyManager.prototype.getDependencies = function (fileName) {
        if (!this.dependencies.hasOwnProperty(fileName)) {
            this.clearDependencies(fileName);
        }
        return this.dependencies[fileName].slice();
    };
    DependencyManager.prototype.addTypeDeclaration = function (fileName) {
        this.knownTypeDeclarations[fileName] = true;
    };
    DependencyManager.prototype.hasTypeDeclaration = function (fileName) {
        return this.knownTypeDeclarations.hasOwnProperty(fileName);
    };
    DependencyManager.prototype.getTypeDeclarations = function () {
        return objectAssign({}, this.knownTypeDeclarations);
    };
    DependencyManager.prototype.getDependencyGraph = function (fileName) {
        var _this = this;
        var appliedDeps = {};
        var result = {
            fileName: fileName,
            dependencies: []
        };
        var walk = function (fileName, context) {
            _this.getDependencies(fileName).forEach(function (depFileName) {
                var depContext = {
                    fileName: depFileName,
                    dependencies: []
                };
                context.dependencies.push(depContext);
                if (!appliedDeps[depFileName]) {
                    appliedDeps[depFileName] = true;
                    walk(depFileName, depContext);
                }
            });
        };
        walk(fileName, result);
        return result;
    };
    DependencyManager.prototype.applyCompiledFiles = function (fileName, deps) {
        if (!this.compiledModules.hasOwnProperty(fileName)) {
            this.clearCompiledModules(fileName);
        }
        this.compiledModules[fileName].forEach(function (mod) {
            deps.add(mod);
        });
    };
    DependencyManager.prototype.applyChain = function (fileName, deps) {
        if (!this.dependencies.hasOwnProperty(fileName)) {
            this.clearDependencies(fileName);
        }
        var appliedDeps = {};
        var graph = this.getDependencyGraph(fileName);
        var walk = function (item) {
            var itemFileName = item.fileName;
            if (!appliedDeps[itemFileName]) {
                appliedDeps[itemFileName] = true;
                deps.add(itemFileName);
                item.dependencies.forEach(function (dep) { return walk(dep); });
            }
        };
        walk(graph);
    };
    return DependencyManager;
})();
exports.DependencyManager = DependencyManager;
var ValidFilesManager = (function () {
    function ValidFilesManager() {
        this.files = {};
    }
    ValidFilesManager.prototype.isFileValid = function (fileName) {
        return !!this.files[fileName];
    };
    ValidFilesManager.prototype.markFileValid = function (fileName) {
        this.files[fileName] = true;
    };
    ValidFilesManager.prototype.markFileInvalid = function (fileName) {
        this.files[fileName] = false;
    };
    return ValidFilesManager;
})();
exports.ValidFilesManager = ValidFilesManager;
/**
 * Emit compilation result for a specified fileName.
 */
var ResolutionError = (function (_super) {
    __extends(ResolutionError, _super);
    function ResolutionError() {
        _super.apply(this, arguments);
    }
    return ResolutionError;
})(Error);
exports.ResolutionError = ResolutionError;
//# sourceMappingURL=deps.js.map