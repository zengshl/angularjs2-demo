var utils_1 = require('./utils');
var ps = require('ps-node');
function getCheckerRuntimeProcess() {
    var opts = {
        command: /node/,
        arguments: /checker-runtime/,
        psargs: 'aux'
    };
    return new Promise(function (resolve, reject) {
        ps.lookup(opts, function (err, resultList) {
            resolve(resultList[0]);
        });
    });
}
;
function kill(p) {
    return new Promise(function (resolve, reject) {
        ps.kill(p.pid, resolve);
    });
}
;
function sleep(time) {
    return new Promise(function (resolve, reject) {
        setTimeout(resolve, time);
    });
}
;
describe('checker test', function () {
    this.timeout(5000);
    var fixture = utils_1.fixturePath(['checker', 'to-check.ts']);
    var config = utils_1.createConfig({
        entry: fixture,
    }, {
        watch: true,
        forkChecker: true,
        loaderQuery: {
            forkChecker: true
        }
    });
    it('should fork checker in separate process', function () {
        yield utils_1.cleanOutputDir();
        var watcher = yield utils_1.watch(config, function () { });
        var pid = yield getCheckerRuntimeProcess();
        utils_1.expect(pid).ok;
        watcher.close();
        yield kill(pid);
    });
    it('should fork only one checker after multiple changes', function () {
        // I didn't get how to test it more precise, so it's more like a proof of work
        yield utils_1.cleanOutputDir();
        var watcher = yield utils_1.watch(config, function () { });
        var pid = yield getCheckerRuntimeProcess();
        utils_1.expect(pid).ok;
        var i = 10;
        while (i--) {
            yield utils_1.touchFile(fixture);
            yield sleep(50);
        }
        yield sleep(2000);
        watcher.close();
        yield kill(pid);
    });
});
//# sourceMappingURL=checker.js.map