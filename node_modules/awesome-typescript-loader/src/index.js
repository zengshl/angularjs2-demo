/// <reference path='../node_modules/typescript/lib/typescriptServices.d.ts' />
/// <reference path="./defines.d.ts"/>
/// <reference path='../typings/tsd.d.ts' />
"use strict";
var _ = require('lodash');
var path = require('path');
var deps_1 = require('./deps');
var cache_1 = require('./cache');
var helpers = require('./helpers');
var instance_1 = require('./instance');
var promisify = require('es6-promisify');
var loaderUtils = require('loader-utils');
var cachePromise = promisify(cache_1.cache);
function loader(text) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield compiler.call(undefined, this, text);
        }
        catch (e) {
            console.error(e, e.stack);
            throw e;
        }
    });
}
function compiler(webpack, text) {
    return __awaiter(this, void 0, Promise, function* () {
        if (webpack.cacheable) {
            webpack.cacheable();
        }
        var options = loaderUtils.parseQuery(webpack.query);
        var instanceName = options.instanceName || 'default';
        var instance = instance_1.ensureInstance(webpack, options, instanceName);
        var state = instance.tsState;
        var callback = webpack.async();
        var fileName = state.normalizePath(webpack.resourcePath);
        var resolver = deps_1.createResolver(webpack._compiler.options.externals, state.options.exclude || [], webpack.resolve, webpack);
        var depsInjector = {
            add: function (depFileName) { return webpack.addDependency(depFileName); },
            clear: webpack.clearDependencies.bind(webpack)
        };
        var applyDeps = _.once(function () {
            depsInjector.clear();
            depsInjector.add(fileName);
            state.fileAnalyzer.dependencies.applyCompiledFiles(fileName, depsInjector);
            if (state.options.reEmitDependentFiles) {
                state.fileAnalyzer.dependencies.applyChain(fileName, depsInjector);
            }
        });
        if (instance.options.externals && !instance.externalsInvoked) {
            if (instance.externalsInvocation) {
                yield instance.externalsInvocation;
            }
            else {
                var promises = instance.options.externals.map(function (external) __awaiter(this, void 0, void 0, function* () {
                    yield state.fileAnalyzer.checkDependencies(resolver, external);
                }));
                instance.externalsInvocation = Promise.all(promises).then(function () {
                    instance.externalsInvoked = true;
                });
                yield instance.externalsInvocation;
            }
        }
        instance.compiledFiles[fileName] = true;
        var doUpdate = false;
        if (instance.options.useWebpackText) {
            if (state.updateFile(fileName, text, true)) {
                doUpdate = true;
            }
        }
        try {
            var wasChanged = yield state.fileAnalyzer.checkDependencies(resolver, fileName);
            if (wasChanged || doUpdate) {
                state.updateProgram();
            }
            var compiledModule = void 0;
            if (instance.options.usePrecompiledFiles) {
                compiledModule = cache_1.findCompiledModule(fileName);
            }
            var transformation = null;
            if (compiledModule) {
                state.fileAnalyzer.dependencies.addCompiledModule(fileName, compiledModule.fileName);
                transformation = {
                    text: compiledModule.text,
                    map: compiledModule.map
                        ? JSON.parse(compiledModule.map)
                        : null
                };
            }
            else {
                function transform() {
                    var resultText;
                    var resultSourceMap = null;
                    var output = state.emit(fileName);
                    var result = helpers.findResultFor(output, fileName);
                    if (result.text === undefined) {
                        throw new Error('No output found for ' + fileName);
                    }
                    if (result.declaration) {
                        webpack.emitFile(path.relative(process.cwd(), result.declaration.sourceName), result.declaration.text);
                    }
                    resultText = result.text;
                    var sourceFileName = fileName.replace(process.cwd() + '/', '');
                    if (result.sourceMap) {
                        resultSourceMap = JSON.parse(result.sourceMap);
                        resultSourceMap.sources = [sourceFileName];
                        resultSourceMap.file = sourceFileName;
                        resultSourceMap.sourcesContent = [text];
                        resultText = resultText.replace(/^\/\/# sourceMappingURL=[^\r\n]*/gm, '');
                    }
                    if (instance.options.useBabel) {
                        var defaultOptions = {
                            inputSourceMap: resultSourceMap,
                            sourceRoot: process.cwd(),
                            filename: fileName,
                            sourceMap: true
                        };
                        var babelOptions = Object.assign({}, defaultOptions, options.babelOptions);
                        var babelResult = instance.babelImpl.transform(resultText, babelOptions);
                        resultText = babelResult.code;
                        resultSourceMap = babelResult.map;
                    }
                    return {
                        text: resultText,
                        map: resultSourceMap
                    };
                }
                if (instance.options.useCache) {
                    transformation = yield cachePromise({
                        source: text,
                        identifier: instance.cacheIdentifier,
                        directory: instance.options.cacheDirectory,
                        options: webpack.query,
                        transform: transform
                    });
                }
                else {
                    transformation = transform();
                }
            }
            var resultText = transformation.text;
            var resultSourceMap = transformation.map;
            if (resultSourceMap) {
                var sourcePath = path.relative(instance.options.sourceRoot || process.cwd(), loaderUtils.getRemainingRequest(webpack));
                resultSourceMap.sources = [sourcePath];
                resultSourceMap.file = fileName;
                resultSourceMap.sourcesContent = [text];
            }
            try {
                callback(null, resultText, resultSourceMap);
            }
            catch (e) {
                console.error('Error in bail mode:', e, e.stack.join
                    ? e.stack.join('\n')
                    : e.stack);
                process.exit(1);
            }
        }
        catch (err) {
            console.error(err.toString(), err.stack.toString());
            callback(err, helpers.codegenErrorReport([err]));
        }
        finally {
            applyDeps();
        }
    });
}
var ForkCheckerPlugin = (function () {
    function ForkCheckerPlugin() {
    }
    ForkCheckerPlugin.prototype.apply = function (compiler) {
        compiler.plugin("watch-run", function (params, callback) {
            compiler._tsFork = true;
            callback();
        });
    };
    return ForkCheckerPlugin;
}());
loader.ForkCheckerPlugin = ForkCheckerPlugin;
module.exports = loader;
//# sourceMappingURL=index.js.map